
/* SOLID원칙
1. SRP(Single Responsiblity Principle : 단일 책임 워칙)
	-> 클래스의 목적에 맞는 메소드들과 변수들만을 가지고 있어야한다.
	reasen>> 클래스여러 너무 여러가지 기능이 섞이게 되면, 클래스 유지보수및 가독성이 떨어지기때문
	ex> 적소환기클래스이면 소환만하고 소환한 적들에 대한 정보만 가지고 있을뿐, 이동이나 조작하는 기능을 포함하면 안된다.

2. OCP(Open Close Princilple : 개방 폐쇄의 원칙)
	-> 캡슐화 원칙으로 생각해도 좋을 듯 하다. 다른 클래스와 조립은 용이하지만 변형은 불가능하게 하는것.
	reasen>> 캡슐화의 원칙으로 멤버를 강제로 변경하려고하면 어디로 튈지 모르는 프로그램이 되기때문에 안정성을 유지하기 위해서
	방법> 매개변수를 받아올때도 그 매개변수의 값에 범위를 주는 코드를 초반에 삽입해서 변수값이 맞지 않으면 실행되지 않게 설계

3. LSP(The Liscov Substitution Principle : 리스코프 치환 법칙)
	-> 하위 기반 타입으로(다운캐스팅)해도 문제없이 변경이 가능해야한다.
	1. 객체가 서로 공통의 기능이 있지만 다른 일을 하면 상속으로 고통의 부분만 상속하고 나머지는 따로 구현

4. ISP(Interface Sergregation Principle : 인터페이스 분리 원칙)
	->사용하지 않을 인터페이스는 구현하지 않는다.
	하나의 포괄적인 인페이스보다 여러개의 구체적 인터페이스가 좋다.
	ex) 이동한다라는 인터페이스보다 두발로 걷는다, 네발로 걷는다, 날아간다 등으로 구체적으로 분리해서 만들어 놓는 것이 좋다.
5. DIP(Dependencyu Inversion Principle : 의존성 역전의 법칙)
	->자신보다 변하기 쉬운것에 의존하지 말것 

	== 만약 무기에 스텟추가 항목이 있다면, 그것을 상속관계의 인터페이스로 구현해서 부모인터페이스만 상속을 받고
	그것을 다형성을 이용해서 착용한 무기에 맞는 능력치 상승 메소드를 호출 할 수 있도록 설계하는 것
	칼은 캐릭터보다 많이 변하기때문에 무기별로 인터페이스를 구현해서 의존하게 되면 코드가 꼬이게된다.
클래스를 작성하는데 있어서 지켜야하는 규약들
*/